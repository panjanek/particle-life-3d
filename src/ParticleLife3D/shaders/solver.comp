#version 430

#pragma optimize(on)

layout(local_size_x = {LocalSizeX}) in;

struct ShaderConfig {
    int particleCount;
    float dt;
    float sigma2;
    float clampVel;
    float clampAcc;
    float fieldSize;
    float cellSize;
    float maxDist;
    int speciesCount;
    float damping;
    int trackedIdx;
    float maxForce;
    float amp;
    float cellCount;
    ivec4 disabled[4];
};

struct Particle
{
   vec4 position;
   vec4 velocity;
   int species;
   int flags;
   int  cellIndex;
   int  _pad1;
};

#define MAX_SPECIES_COUNT     10
#define KEYPOINTS_COUNT       6
#define FORCE_COUNT           (MAX_SPECIES_COUNT * MAX_SPECIES_COUNT * KEYPOINTS_COUNT)

layout(std140, binding = 0) uniform ConfigBuffer {
    ShaderConfig config;
};

layout(std430, binding = 1) readonly buffer InputBuffer
{
    Particle inParticles[];
};

layout(std430, binding = 2) writeonly buffer OutputBuffer
{
    Particle outParticles[];
};

layout(std430, binding = 4) readonly buffer ForceBuffer {
    vec4 forces[];
};

layout(std430, binding = 5) writeonly buffer TrackingBuffer
{
    Particle tracked;
};

void torus_pos(inout vec4 pos)
{
    if (pos.x > config.fieldSize)
        pos.x -= config.fieldSize;
    else if (pos.x < 0)
        pos.x += config.fieldSize;

    if (pos.y > config.fieldSize)
        pos.y -= config.fieldSize;
    else if (pos.y < 0)
        pos.y += config.fieldSize;

    if (pos.z > config.fieldSize)
        pos.z -= config.fieldSize;
    else if (pos.z < 0)
        pos.z += config.fieldSize;
}

void torus_dist(inout vec4 d)
{
    if (abs(d.x) > config.fieldSize / 2)
        d.x -= config.fieldSize*sign(d.x);

    if (abs(d.y) > config.fieldSize / 2)
        d.y -= config.fieldSize*sign(d.y);

    if (abs(d.z) > config.fieldSize / 2)
        d.z -= config.fieldSize*sign(d.z);
}

float evaluateForceForOffset(uint offset, float dist)
{
    for(int i=1; i<KEYPOINTS_COUNT; i++)
        if (forces[i-1].x == forces[i].x)
            return 0;


    // Clamp distance to valid range
    dist = clamp(dist, forces[offset].x, forces[offset+5].x);

    // Find the segment [i, i+1] that contains dist
    for (int i = 0; i < KEYPOINTS_COUNT-1; ++i)
    {
        float x0 = forces[offset+i].x;
        float x1 = forces[offset+i + 1].x;

        if (dist <= x1)
        {
            float t = (dist - x0) / (x1 - x0);
            return mix(forces[offset+i].y, forces[offset+i + 1].y, t);
        }
    }

    // Safety fallback (should never happen)
    return 0.0;
}

vec4 compute_single_acceleration(Particle p, Particle other)
{
    vec4 d = other.position - p.position;
    torus_dist(d);
    vec4 single_acc = vec4(0,0,0,0);
    if (abs(d.x) <= config.maxDist && abs(d.y) <= config.maxDist && abs(d.z) <= config.maxDist)
    {
        float r2 = dot(d, d) + config.sigma2;
        float r = sqrt(r2);
        uint forceOffset = (p.species * MAX_SPECIES_COUNT + other.species) * KEYPOINTS_COUNT;
        float f = evaluateForceForOffset(forceOffset, r);
        single_acc = config.amp * f * d / r;
    }

    return single_acc;
}

vec4 compute_total_acceleration(uint idx, Particle p)
{
    vec4 acc = vec4(0.0);
    for(uint otherIdx = 0; otherIdx < config.particleCount; otherIdx++)
    {
        if (idx != otherIdx)
        {
             Particle other = inParticles[otherIdx];
             acc += compute_single_acceleration(p, other);
        }
    }

    return acc;
}

void update_one(uint idx)
{
    Particle p = inParticles[idx];
    
    vec4 acc = compute_total_acceleration(idx, p);
    vec4 vel = p.velocity;
    vec4 pos = p.position;

    //clamp acceleration
    if (config.clampAcc > 0.0)
    {
        float acc2 = dot(acc, acc);
        float maxAcc2 = config.clampAcc * config.clampAcc;
        acc *= inversesqrt(max(acc2, maxAcc2)) * config.clampAcc;
    }

    //integrate velocity
    vel += acc * config.dt;
    
    //clamp velocity
    if (config.clampVel > 0)
    {
        float vel2 = dot(vel, vel);
        float maxVel2 = config.clampVel * config.clampVel;
        vel *= inversesqrt(max(vel2, maxVel2)) * config.clampVel;
    }

    //exp drag
    float speed = length(vel);
    float drag = exp(-config.damping * speed * config.dt);
    vel *= drag;

    //integrate position
    pos += vel * config.dt;

    torus_pos(pos);

    //prepare updated particle struct
    p.position = pos;
    p.velocity = vel;
    p.flags = 0;
    if (config.trackedIdx > -1 && config.trackedIdx == idx)
    {
        p.flags = 1;
        tracked = p;
    }

    bool isDisabled = config.disabled[p.species / 4][p.species % 4] != 0;
    if (isDisabled)
        p.flags = 2;

    outParticles[idx] = p;
}

void main()
{
    uint idx = gl_GlobalInvocationID.x;
    if (idx >=0 && idx < config.particleCount) 
    {
        update_one(idx);
    }
}